# -*- coding: utf-8 -*-
"""Modelling and prediction.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1fcjWWOd8DqyHn4Zo8Tzq9uuUWpfySLIP

## Data analysis backbone

Considering that estimating the commercial value of the more than two million properties in the city could be using prediction methods, the business purpose of Cadastre Bogotá can be approached as a data science project having as the main purpose establishing the commercial appraisals, to later obtain the cadastral appraisals using prediction tools. The modelling section, per time processing request, is going to be performed just for one the locations of the city, taking as assumption that prices of the properties varies among the locations.
"""

from google.colab import drive 
drive.mount('/content/gdrive')

#Setting libraries required for the notebook
import pandas as pd
import numpy as np
from sqlalchemy import create_engine
from sklearn.model_selection import train_test_split
from sklearn import linear_model

#Retrieving input dataset
postgres_str = ('postgresql://postgres:OaklandStreet@localhost:5432/ExploitationZone')
cnx = create_engine(postgres_str)
df = pd.read_sql('SELECT * FROM targetUsageData', cnx)
df.describe()

df.locationCode.value_counts()
df = df[df["locationCode"] > 8]

"""**Feature analysis:**

Using the DataFrame generated in the previous steps:
* Filter the dataset to only these features
    - Explanatory: *locationCode*, *stratumCode*, *totalArea*, *builtArea*
    - Response: *price*
"""

X=df[['locationCode', 'stratumCode', 'totalArea', 'builtArea']]
y=df["price"]

"""* Scatterplot matrix



"""

pd.plotting.scatter_matrix(X, c=y);

"""* Linear regression"""

from sklearn.model_selection import train_test_split

#Partition 30-70
X_train, X_test, y_train, y_test = train_test_split(X, y, test_size=0.3, random_state=42)

from sklearn.linear_model import LinearRegression

regressor = LinearRegression()
regressor.fit(X_train, y_train)
print(regressor.coef_)

"""Mean Squared Error"""

from sklearn.metrics import mean_squared_error

pred = regressor.predict(X_test)
print("Train Set Mean Squared Error: " ,np.sqrt(mean_squared_error(y_train, regressor.predict(X_train))))
print("Test Set Mean Sqaured Error: ", np.sqrt(mean_squared_error(y_test, regressor.predict(X_test))))

from matplotlib import pyplot as plt
import pylab as pl
min_pt = X.min() * regressor.coef_[0] + regressor.intercept_
max_pt = X.max() * regressor.coef_[0] + regressor.intercept_

pl.figure(figsize = (10, 6))
pl.plot([X.min(), X.max()], [min_pt, max_pt], label="predicción")
pl.plot(X_train, y_train, 'o', label="training");
pl.plot(X_test, y_test, 'o', label="test");
pl.legend(loc='best');

"""k-fold Cross-Validation"""

from sklearn.metrics import recall_score, f1_score,confusion_matrix
from sklearn.model_selection import cross_val_score
regressor.score(X,y)

CV_MSE = np.mean(-cross_val_score(regressor, X_train, y_train, cv = 10 ,scoring = "neg_mean_squared_error" ))
CV_RMSE = np.sqrt(CV_MSE)
print("Validated Mean Squared Error: ", CV_MSE)
print("Validated Root Mean Squared Error: ", CV_RMSE)

y_testpred = regressor.predict(X_test)
lot(y_testpred